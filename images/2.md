### **Cours sur la complexité des algorithmes**

#### **1. Introduction à la complexité**
La **complexité** d'un algorithme mesure la quantité de ressources (temps et espace) nécessaires pour exécuter cet algorithme en fonction de la taille des données d'entrée. On distingue principalement :
- **Complexité temporelle** : Temps nécessaire pour exécuter l'algorithme.
- **Complexité spatiale** : Quantité de mémoire utilisée.

#### **2. Notion de complexité asymptotique**
La complexité asymptotique permet d'évaluer le comportement d'un algorithme lorsque la taille des données d'entrée devient très grande. On utilise la notation **Big O** (O(n), O(n²), etc.) pour décrire cette complexité.

- **O(1)** : Complexité constante (exemple : accès à un élément d'un tableau).
- **O(n)** : Complexité linéaire (exemple : recherche séquentielle dans une liste).
- **O(n²)** : Complexité quadratique (exemple : tri à bulles, tri par insertion).
- **O(log n)** : Complexité logarithmique (exemple : recherche dichotomique).

#### **3. Comment calculer la complexité ?**
Pour calculer la complexité, on compte le nombre d'opérations significatives (comparaisons, échanges, etc.) en fonction de la taille des données d'entrée.

---

### **Tri à bulles (Bubble Sort)**

#### **1. Algorithme en Python**
```python
def bubble_sort(L):
    n = len(L)
    for i in range(n):
        for j in range(0, n-i-1):
            if L[j] > L[j+1]:
                L[j], L[j+1] = L[j+1], L[j]
    return L
```

#### **2. Explication du dénombrement des comparaisons**
- **Boucle externe (i)** : Parcourt chaque élément de la liste.
- **Boucle interne (j)** : Compare les éléments adjacents et les échange si nécessaire.

**Pourquoi `n-i-1` comparaisons ?**
- À chaque itération de la boucle externe (`i`), le plus grand élément "bulle" vers la fin de la liste.
- Après `i` itérations, les `i` derniers éléments sont déjà triés. On n'a donc pas besoin de les comparer à nouveau.
- Ainsi, pour chaque `i`, on effectue `n-i-1` comparaisons.

#### **3. Complexité temporelle**
- **Pire des cas** : \(O(n^2)\) (toutes les comparaisons et échanges sont effectués).
- **Meilleur des cas** : \(O(n)\) (si la liste est déjà triée, une seule passe suffit).

#### **4. Complexité spatiale**
- **O(1)** : Le tri à bulles est un tri en place, il n'utilise pas de mémoire supplémentaire.

---

### **Tri par insertion (Insertion Sort)**

#### **1. Algorithme en Python**
```python
def insertion_sort(L):
    for i in range(1, len(L)):
        key = L[i]
        j = i-1
        while j >= 0 and key < L[j]:
            L[j+1] = L[j]
            j -= 1
        L[j+1] = key
    return L
```

#### **2. Explication du dénombrement des comparaisons**
- **Boucle externe (i)** : Parcourt chaque élément de la liste à partir du deuxième.
- **Boucle interne (j)** : Compare l'élément courant (`key`) avec les éléments précédents et les décale si nécessaire.

**Pourquoi `1 + 2 + ... + (n-1)` comparaisons ?**
- Pour chaque élément `i`, on effectue au maximum `i` comparaisons pour trouver sa position correcte dans la partie triée de la liste.
- Le nombre total de comparaisons est donc la somme des `n-1` premiers entiers : \(1 + 2 + ... + (n-1) = \frac{n(n-1)}{2}\).

#### **3. Complexité temporelle**
- **Pire des cas** : \(O(n^2)\) (chaque élément doit être comparé avec tous les précédents).
- **Meilleur des cas** : \(O(n)\) (si la liste est déjà triée, une seule comparaison par élément suffit).

#### **4. Complexité spatiale**
- **O(1)** : Le tri par insertion est un tri en place, il n'utilise pas de mémoire supplémentaire.

---


### **Résumé des complexités**
| Algorithme       | Complexité temporelle (pire des cas) | Complexité spatiale |
|------------------|--------------------------------------|----------------------|
| Tri à bulles     | \(O(n^2)\)                          | \(O(1)\)             |
| Tri par insertion| \(O(n^2)\)                          | \(O(1)\)             |

Ces deux algorithmes ont une complexité quadratique, ce qui signifie qu'ils deviennent moins efficaces pour de grandes listes. Cependant, ils sont simples à comprendre et à implémenter, ce qui les rend utiles pour de petites listes ou des cas d'apprentissage.

Si vous avez d'autres questions ou besoin de précisions, n'hésitez pas !
