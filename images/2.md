### **Comprendre la complexité du tri à bulles : Explication étape par étape et vulgarisée**

---

#### **1. Qu’est-ce que le tri à bulles ?**
Imagine que tu as une rangée de bulles (ou de nombres) dans un tube. Chaque bulle a une valeur, et tu veux les ranger dans l’ordre croissant. Le tri à bulles fonctionne en comparant deux bulles voisines et en les échangeant si elles ne sont pas dans le bon ordre. Ce processus est répété jusqu’à ce que toutes les bulles soient bien rangées.

**Exemple :**
Si tu as la liste `[3, 6, 1, 4, 0, 2, 9]`, le tri à bulles va comparer 3 et 6, puis 6 et 1, etc., et échanger les valeurs si nécessaire.

---

#### **2. Comment fonctionne l’algorithme ?**
Voici le code du tri à bulles en Python :
```python
def bubble_sort(L):
    n = len(L)
    for i in range(n):
        for j in range(0, n-i-1):
            if L[j] > L[j+1]:
                L[j], L[j+1] = L[j+1], L[j]
    return L
```

**Explication :**
- **`n`** est la taille de la liste.
- **`i`** est un compteur qui parcourt la liste du début à la fin.
- **`j`** est un compteur qui compare les éléments voisins.

---

#### **3. Pourquoi `n-i-1` comparaisons ?**
Pour comprendre pourquoi on utilise `n-i-1`, analysons ce qui se passe à chaque étape :

- **Première passe (`i = 0`)** :
  - On compare les éléments de la position `0` à la position `n-1` (toute la liste).
  - Après cette passe, le plus grand élément "bulle" jusqu’à la fin de la liste.

- **Deuxième passe (`i = 1`)** :
  - On n’a plus besoin de comparer le dernier élément (car il est déjà à sa place).
  - On compare donc les éléments de la position `0` à la position `n-2`.

- **Troisième passe (`i = 2`)** :
  - Les deux derniers éléments sont déjà triés.
  - On compare les éléments de la position `0` à la position `n-3`.

**En résumé :**
À chaque passe `i`, on sait que les `i` derniers éléments sont déjà triés. On n’a donc pas besoin de les comparer à nouveau. C’est pour cela qu’on utilise `n-i-1` comparaisons.

---

#### **4. Calcul du nombre total de comparaisons**
Pour calculer le nombre total de comparaisons, on additionne le nombre de comparaisons effectuées à chaque passe :
- **Première passe** : `n-1` comparaisons
- **Deuxième passe** : `n-2` comparaisons
- ...
- **Dernière passe** : `1` comparaison

**Total des comparaisons :**
\[
(n-1) + (n-2) + ... + 1 = \frac{n(n-1)}{2}
\]

**Exemple avec `n = 7` :**
\[
6 + 5 + 4 + 3 + 2 + 1 = 21 \text{ comparaisons}
\]

---

#### **5. Complexité temporelle**
La complexité temporelle du tri à bulles est **quadratique**, notée \(O(n^2)\). Cela signifie que si tu doubles la taille de la liste, le temps nécessaire pour la trier sera multiplié par 4.

**Pourquoi \(O(n^2)\) ?**
- Le nombre total de comparaisons est proportionnel à \(n^2\) (car on a une boucle imbriquée).
- Même si dans le meilleur des cas (liste déjà triée), on peut optimiser l’algorithme pour qu’il s’arrête plus tôt, dans le pire des cas, il faut effectuer toutes les comparaisons.

---

#### **6. Complexité spatiale**
Le tri à bulles est un **tri en place**, ce qui signifie qu’il n’utilise pas de mémoire supplémentaire pour trier la liste. La complexité spatiale est donc **constante**, notée \(O(1)\).

---

#### **7. Exemple concret avec la liste `[3, 6, 1, 4, 0, 2, 9]`**

**Première passe (`i = 0`)** :
- Compare 3 et 6 → pas d’échange.
- Compare 6 et 1 → échange → `[3, 1, 6, 4, 0, 2, 9]`
- Compare 6 et 4 → échange → `[3, 1, 4, 6, 0, 2, 9]`
- Compare 6 et 0 → échange → `[3, 1, 4, 0, 6, 2, 9]`
- Compare 6 et 2 → échange → `[3, 1, 4, 0, 2, 6, 9]`

**Deuxième passe (`i = 1`)** :
- Compare 3 et 1 → échange → `[1, 3, 4, 0, 2, 6, 9]`
- Compare 3 et 4 → pas d’échange.
- Compare 4 et 0 → échange → `[1, 3, 0, 4, 2, 6, 9]`
- Compare 4 et 2 → échange → `[1, 3, 0, 2, 4, 6, 9]`

**Troisième passe (`i = 2`)** :
- Compare 1 et 3 → pas d’échange.
- Compare 3 et 0 → échange → `[1, 0, 3, 2, 4, 6, 9]`
- Compare 3 et 2 → échange → `[1, 0, 2, 3, 4, 6, 9]`

**Quatrième passe (`i = 3`)** :
- Compare 1 et 0 → échange → `[0, 1, 2, 3, 4, 6, 9]`

**Cinquième et sixième passes (`i = 4, i = 5`)** :
- Aucune échange nécessaire, la liste est triée.

---

#### **8. Résumé**
- **Tri à bulles** : Compare et échange les éléments voisins jusqu’à ce que la liste soit triée.
- **Nombre de comparaisons** : \(\frac{n(n-1)}{2}\).
- **Complexité temporelle** : \(O(n^2)\).
- **Complexité spatiale** : \(O(1)\).

---

-------------------------------
-------------------------------
-------------------------------
-------------------------------

### **Comprendre la complexité du tri par insertion : Explication étape par étape et vulgarisée**

---

#### **1. Qu’est-ce que le tri par insertion ?**
Imagine que tu joues aux cartes et que tu reçois une main désordonnée. Tu veux ranger tes cartes dans l’ordre croissant. Le tri par insertion fonctionne en prenant une carte à la fois et en l’insérant à sa place correcte parmi les cartes déjà triées.

**Exemple :**
Si tu as la liste `[3, 6, 1, 4, 0, 2, 9]`, le tri par insertion va prendre chaque élément un par un et le placer au bon endroit dans la partie déjà triée de la liste.

---

#### **2. Comment fonctionne l’algorithme ?**
Voici le code du tri par insertion en Python :
```python
def insertion_sort(L):
    for i in range(1, len(L)):
        key = L[i]
        j = i-1
        while j >= 0 and key < L[j]:
            L[j+1] = L[j]
            j -= 1
        L[j+1] = key
    return L
```

**Explication :**
- **`i`** est l’indice de l’élément que tu veux insérer dans la partie triée.
- **`key`** est la valeur de l’élément que tu veux insérer.
- **`j`** est l’indice utilisé pour parcourir la partie triée de la liste et trouver la bonne position pour `key`.

---

#### **3. Pourquoi `1 + 2 + ... + (n-1)` comparaisons ?**
Pour comprendre pourquoi on parle de `1 + 2 + ... + (n-1)` comparaisons, analysons ce qui se passe à chaque étape :

- **Première itération (`i = 1`)** :
  - Tu prends le deuxième élément (`6`) et tu le compares avec le premier élément (`3`).
  - Une seule comparaison est nécessaire.

- **Deuxième itération (`i = 2`)** :
  - Tu prends le troisième élément (`1`) et tu le compares avec les deux éléments déjà triés (`3` et `6`).
  - Deux comparaisons sont nécessaires.

- **Troisième itération (`i = 3`)** :
  - Tu prends le quatrième élément (`4`) et tu le compares avec les trois éléments déjà triés (`1`, `3`, et `6`).
  - Trois comparaisons sont nécessaires.

**En résumé :**
À chaque itération `i`, tu dois comparer l’élément `key` avec les `i` éléments déjà triés. Dans le pire des cas, tu fais `i` comparaisons.

---

#### **4. Calcul du nombre total de comparaisons**
Pour calculer le nombre total de comparaisons, on additionne le nombre de comparaisons effectuées à chaque itération :
- **Première itération** : `1` comparaison
- **Deuxième itération** : `2` comparaisons
- ...
- **Dernière itération** : `n-1` comparaisons

**Total des comparaisons :**
\[
1 + 2 + ... + (n-1) = \frac{n(n-1)}{2}
\]

**Exemple avec `n = 7` :**
\[
1 + 2 + 3 + 4 + 5 + 6 = 21 \text{ comparaisons}
\]

---

#### **5. Complexité temporelle**
La complexité temporelle du tri par insertion est **quadratique**, notée \(O(n^2)\). Cela signifie que si tu doubles la taille de la liste, le temps nécessaire pour la trier sera multiplié par 4.

**Pourquoi \(O(n^2)\) ?**
- Dans le pire des cas (liste triée à l’envers), chaque élément doit être comparé avec tous les éléments précédents.
- Le nombre total de comparaisons est donc proportionnel à \(n^2\).

**Cas favorable :**
Si la liste est déjà triée, chaque élément n’a besoin que d’une seule comparaison pour être inséré. La complexité devient alors \(O(n)\).

---

#### **6. Complexité spatiale**
Le tri par insertion est un **tri en place**, ce qui signifie qu’il n’utilise pas de mémoire supplémentaire pour trier la liste. La complexité spatiale est donc **constante**, notée \(O(1)\).

---

#### **7. Exemple concret avec la liste `[3, 6, 1, 4, 0, 2, 9]`**

**Première itération (`i = 1`)** :
- `key = 6`, `j = 0`
- Compare `6` et `3` → pas d’échange.
- Liste : `[3, 6, 1, 4, 0, 2, 9]`

**Deuxième itération (`i = 2`)** :
- `key = 1`, `j = 1`
- Compare `1` et `6` → décale `6` → `[3, 6, 6, 4, 0, 2, 9]`
- Compare `1` et `3` → décale `3` → `[3, 3, 6, 4, 0, 2, 9]`
- Insère `1` à sa place → `[1, 3, 6, 4, 0, 2, 9]`

**Troisième itération (`i = 3`)** :
- `key = 4`, `j = 2`
- Compare `4` et `6` → décale `6` → `[1, 3, 6, 6, 0, 2, 9]`
- Compare `4` et `3` → pas de décalage.
- Insère `4` à sa place → `[1, 3, 4, 6, 0, 2, 9]`

**Quatrième itération (`i = 4`)** :
- `key = 0`, `j = 3`
- Compare `0` et `6` → décale `6` → `[1, 3, 4, 6, 6, 2, 9]`
- Compare `0` et `4` → décale `4` → `[1, 3, 4, 4, 6, 2, 9]`
- Compare `0` et `3` → décale `3` → `[1, 3, 3, 4, 6, 2, 9]`
- Compare `0` et `1` → décale `1` → `[1, 1, 3, 4, 6, 2, 9]`
- Insère `0` à sa place → `[0, 1, 3, 4, 6, 2, 9]`

**Cinquième itération (`i = 5`)** :
- `key = 2`, `j = 4`
- Compare `2` et `6` → décale `6` → `[0, 1, 3, 4, 6, 6, 9]`
- Compare `2` et `4` → décale `4` → `[0, 1, 3, 4, 4, 6, 9]`
- Compare `2` et `3` → décale `3` → `[0, 1, 3, 3, 4, 6, 9]`
- Compare `2` et `1` → pas de décalage.
- Insère `2` à sa place → `[0, 1, 2, 3, 4, 6, 9]`

**Dernière itération (`i = 6`)** :
- `key = 9`, `j = 5`
- Compare `9` et `6` → pas de décalage.
- Liste finale : `[0, 1, 2, 3, 4, 6, 9]`

---

#### **8. Résumé**
- **Tri par insertion** : Prend chaque élément un par un et l’insère à sa place correcte dans la partie triée de la liste.
- **Nombre de comparaisons** : \(\frac{n(n-1)}{2}\) dans le pire des cas.
- **Complexité temporelle** : \(O(n^2)\) dans le pire des cas, \(O(n)\) dans le meilleur des cas.
- **Complexité spatiale** : \(O(1)\).

---
